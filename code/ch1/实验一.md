![8bc6e1defa9bafc924b71af1280579bd](实验一.assets/8bc6e1defa9bafc924b71af1280579bd.png)

# 背景知识：

代码模板：

```asm
;==========================================
; 标准 DOS .EXE 程序模板（16位）
;==========================================
DATA SEGMENT
    ; 在这里定义你的数据
    msg DB 'Hello, World!$'
DATA ENDS

STACK SEGMENT STACK
    DW 128 DUP(?)      ; 256 字节堆栈
STACK ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA, SS:STACK

START:
    ; ★★★ 关键初始化：设置 DS 指向 DATA 段 ★★★
    MOV AX, DATA
    MOV DS, AX

    ; ★★★（可选）设置 ES 也指向 DATA（如果需要字符串操作）★★★
    ; MOV ES, AX

    ; ———————— 你的主程序代码从这里开始 ————————
    MOV DX, OFFSET msg
    MOV AH, 09H        ; DOS 输出字符串（以 $ 结尾）
    INT 21H

    ; ———————— 程序结束 ————————
    MOV AH, 4CH        ; DOS 功能：退出程序
    INT 21H

CODE ENDS
END START
```

初始化步骤：

| 步骤             | 作用                                                 |
| ---------------- | ---------------------------------------------------- |
| `ASSUME DS:DATA` | 告诉汇编器：数据在 `DATA` 段，生成代码时用 `DS` 寻址 |
| `MOV AX, DATA`   | 获取数据段的段地址（通过符号 `DATA`）                |
| `MOV DS, AX`     | **真正设置 DS 寄存器**，使其指向你的数据段           |

**说明：**

①在 16 位实模式（如 DOS）下，CPU 使用 **段寄存器 + 偏移地址** 来访问内存：

- 逻辑地址 = `段寄存器 × 16 + 偏移`
- 常见段寄存器：`CS`（代码段）、`DS`（数据段）、`SS`（堆栈段）、`ES`（附加段）

>  **CS 由操作系统自动设置**（指向程序代码起始）， **DS 不会自动指向你的数据段**

------

②`ASSUME` 是仅给汇编器看的“提示”

```asm
ASSUME CS:CODE, DS:DATA
```

- `ASSUME` **不是 CPU 指令**，它只是告诉 **汇编器（如 MASM/TASM）**：

  > “当写 `MOV AX, var` 时，这个 `var` 在 `DATA` 段里，用 `DS` 作为段寄存器生成代码。”

-  **`ASSUME` 不会改变任何寄存器的值**

-  如果不手动设置 `DS`，即使写了 `ASSUME DS:DATA`，`DS` 的值仍是随机的--通常放在PSP段。

- PSP（Program Segment Prefix）

  - DOS 加载程序时，会把 **PSP（256 字节）** 放在程序代码段之前。
  - 初始时 `DS` 和 `ES` 都指向 PSP 段，**不是你的数据段**！
  - 所以必须显式设置 `DS`。

③ 如何设置--`MOV AX, DATA` 再 `MOV DS, AX`

```asm
DATA SEGMENT
    msg DB 'Hello$'
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA    ; ← 把 DATA 段的段地址加载到 AX
    MOV DS, AX      ; ← 再把 AX 赋给 DS
    ; 现在 DS 指向你的数据段，可以安全访问 msg 了
    LEA DX, msg
    MOV AH, 09H
    INT 21H
    ; ...
CODE ENDS
END START
```

- `DATA` 是一个**汇编时确定的符号**，代表数据段的**段地址**。
- 但 **不能直接 `MOV DS, DATA`**，因为 x86 不允许**立即数直接传给段寄存器**（语法非法）。
- 所以必须通过通用寄存器（如 `AX`）中转。

# 1.test1

录入程序运行，练习调试命令

1）代码

```asm
Data segment
String db 'I love China!$'
Data ends
code segment
assume cs:code,ds:data
start:
    mov ax,data
    mov ds,ax
    mov dx,offset String
    mov ah,09h
    int 21h
    mov ah,4ch
    int 21h
code ends
end start
```

2）运行后调试

![image-20251016133954951](实验一.assets/image-20251016133954951.png)

①反汇编命令U

```asm
u[地址范围]
```

![image-20251016134442828](实验一.assets/image-20251016134442828.png)

②运行程序命令G

```
g[=起始地址][终止地址]
```

或者在代码中加入`INT 3`设置断点，g命令就能直接运行到断点处停止

![image-20251016134636939](实验一.assets/image-20251016134636939.png)

③单步跟踪指令T

```
t[=起始地址][指令条数]
```

![image-20251016135315189](实验一.assets/image-20251016135315189.png)

④单步执行指令P

当遇到循环、重复的字符指令、软件中断或者子例程时，T命令会进入调用，产生陌生程序，不知道要跳到哪里去了，这时就需要P命令

，不过跳过中断是要确保中断是**快速执行，无等待，可预测的**，否则会发生错误。

![image-20251016140240002](实验一.assets/image-20251016140240002.png)

# 2.test2

编写程序实现两操作数相减运算，结果放在数据段的偏移地址为0016H单元。

```asm
data segment
    ORG 0016h            ; 设置数据段起始地址为0016H
    result dw ?           ; 定义一个存放结果的变量（位置假设为0016H）
data ends

code segment
assume cs:code, ds:data
start:
    mov ax, data          ; 将数据段地址装入 DS
    mov ds, ax

    mov ax, 0038h         ; AX ← 0038H
    mov bx, 0010h         ; BX ← 0010H
    sub ax, bx            ; AX ← AX - BX = 0038H - 0010H = 0028H

    mov result, ax       ; 把 AX 中的结果写入resullt
    
    mov ah, 4ch           ; 返回 DOS
    int 21h
code ends
end start
```

①AX,BX寄存器分别赋值为0038H和0010H。

![image-20251016143432541](实验一.assets/image-20251016143432541.png)

②AX与BX的内容相减（sub指令），结果在AX中（该指令为 SUB AX,BX）。

![image-20251016143539164](实验一.assets/image-20251016143539164.png)

③用寻址方式将相减的结果保存到0016H。

![image-20251016144037073](实验一.assets/image-20251016144037073.png)

# 3.test3

①编写程序实现”hello，world！My name is xx.”。

![image-20251016151019382](实验一.assets/image-20251016151019382.png)

②将第二十六个字符处的内容，通过五种寻址方式分别送入DH、DL、BH、BL、CL中，观察寄存器内容的前后变化。

```asm
    ; -------------------------
    ; 1. 直接寻址（Direct Addressing）
    mov dl, msg[25]      ; 第26个字符到 DL

    ; 2. 寄存器间接寻址（Register Indirect）
    mov bx, 25
    mov dh, [msg+bx]     ; 第26个字符到 DH

    ; 3. 基址加变址寻址（Base + Index）
    mov bx, 0
    mov si, 25
    mov bh, [bx+si+msg]  ; 第26个字符到 BH

    ; 4. 寄存器相对 BP 寻址（BP + displacement）
    mov bp, 0
    mov bl, [bp+msg+25]  ; 第26个字符到 BL

    ; 5. 立即偏移（Offset）寻址
    mov cl, [msg+25]     ; 第26个字符到 CL
```

③可以在结束前设置断点，那么就可以调试时用g命令运行到断点后，查看寄存器状态

![image-20251027114849247](实验一.assets/image-20251027114849247.png)



# 4.test4

编写程序：实现接收键盘输入的连续俩个数字字符，将对应的数字值求和，将结果保存在BL中，然后保存到数据段第10个字节开始的位置。

①调用DOS系统功能号01H来接受输入的字符，输入的字符是以ASCII值的大小保存在AL中的。

②第十个字节段地址是0009,还要是字节，因此可以用org命令和db在此先开辟一个空间

```asm
data segment
    ORG 0009H            ; 设置数据段起始地址为0009H
    result db ?   ;将结果存放在数据段的第10个字节开始的位置
data ends

code segment
    assume cs:code, ds:data
start:
    mov ax, data          ; 将数据段地址装入 DS
    mov ds, ax          ; 初始化数据段
    
    ; 接收第一个数字字符
    mov ah, 01h         ; 功能号：读取字符
    int 21h
    sub al, '0'         ; 将ASCII码转换为数字值
    mov bl, al          ; 暂时保存到BL
    
    ; 接收第二个数字字符  
    mov ah, 01h
    int 21h
    sub al, '0'         ; 将ASCII码转换为数字值
    
    ; 求和
    add bl, al          ; BL = 第一个数字 + 第二个数字
    
    ; 将结果保存到数据段第10个字节开始的位置
    mov result, bl
    
    ; 程序结束
    mov ah, 4ch
    int 21h
code ends
	 end start
```

②用t命令调试代码，第一个数字输入3，第二个输入2，然后用d命令可以看到在内存0009位置成功保存两者和

![image-20251024110841111](实验一.assets/image-20251024110841111.png)

![image-20251024111035683](实验一.assets/image-20251024111035683.png)

